ToDo LoRaWAN Semtech Refernce stack:

	-	Wrapper functions for the main loop and VE implementation
		- Optionally an extra callback for certain events.

	-	RFM DIO. Are all DIO pins used or not? Specificly DIO2, 3 and 4
		|	Gerben had already said that connecting the unconnected DIO pins shouldn't be a problem with the nRF52840
		
	-	Backend opzetten voor 1.1.
	
	-	Lifetime counter opslaan in Flash en bij init ophalen.
				
	-	Het ophalen van de keys zit niet standaard ingebouwd in de loramac laag, wat voor controle en verificatie handig zou zijn.
	
	-	Check changes I've made compared to the default LoRaWAN Semtech Stack
	
	-	Write a conversion document with all the changes I've had to do, to get it running.
	
	-	Low power testen
	
	-	LoRaWAN 1.1 specificatie extra doornemen
		
	
2019-06-05:	
-	RX2 slot van Data bericht 	
	Opgelost door de functie insert timer aan te passen die nog de timestamps vergelijk om een nieuwe timer in de linked list te plaatsen.
	
-RX2 datarate 
		TX datarate verlaagd
		
- Tijd tot latere transmissie gebruiken voor nieuwe pogingen tot versturen van data.
		
- RX2 timing klopt niet, delays zijn veel langer dan verwacht. Er lijkt iets in het timing mechanisme verkeerd te gaan.
	- Als de gateway wordt uitgeschakeld werkt de timing van het join request wel goed.
	o Misschien een probleem met de lengte van de delay?
	+ RX2 timeout window is maar 60 ms. Kan komen omdat nu SF9 wordt geluisterd.
	Bij het RX1 timeout wordt er een hele lange delay ingesteld die niet klopt in volgorde?
- Geen antwoord op confirmed berichten	
	Direct na joinen wordt een berciht verstuurd, delay toepassen?

Op RX1 event wordt de rfm ingeschakeld en een rx timeout counter gestart. De RFM timeout wordt al eerder actief dan dat deze timer activeert.

	
	
	
RX2 functie wordt al aangeroepen na het starten van RX1.
De timers werken via een linked list constructie, waarbij de timers door verwijzen naar elkaar to NULL

Bij elke timer start wordt de Elapsed timer mee gegeven en opgeteld aan de tijd dat er gewacht moet worden. De RTCappTimer wil echter enkel de interrupt tijd weten ten opzichte van nu. Bijvoorbeeld een delay van 500ms.
Als de RTCappTimer interrupt wordt er gekekeken of dat de timers al afgelopen zijn door middel van de RtcGetTimerElapsedTicks() functie, maar deze geeft enkel het verschil in Ticks terug sinds de laatste RTC interrupt, waardoor altijd alle
functies worden aangeroepen die actief zijn.
	
	
	// join
[00:00:01.792,553] <info> app: RTC start Alarm: 197656 Ticks / 6031 ms
[00:00:01.792,614] <info> app: RTC start Alarm: 164890 Ticks / 5032 ms
[00:00:01.792,653] <info> app: RX1: 164888 Ticks/5032 ms, RX2: 197656 Ticks/6032 ms

/frame
[00:00:10.798,150] <info> app: RTC start Alarm: 231573 Ticks / 7067 ms
[00:00:10.798,212] <info> app: On Time: seconds: 10, milliseconds: 792
[00:00:10.805,188] <info> app: Tx Done
[00:00:10.805,291] <info> app: RTC start Alarm: 103202 Ticks / 3149 ms
[00:00:10.805,353] <info> app: RTC start Alarm: 71910 Ticks / 2194 ms
[00:00:10.805,392] <info> app: RX1: 33816 Ticks/1032 ms, RX2: 65110 Ticks/1987 ms
3149-1987 = 1162
2194-1032 = 1162 
2121898185-2120732787 = 1165398
Er wordt zo'n 1162 milliseconden toegevoegd aan de tijd van de RX1 en RX2 tijdsloten bij het frame

Oftwel de Tx tijd wordt bij de tijdsloten opgeteld



Tijdens Tx start wordt natuurlijk een timer gestart om een timeout te genereren als er geen Tx done signaal van de module wordt ontvangen.
 Op TxDone event worden de Rx1 en Rx2 timers gestart met onderstaande de code snippet:
 
	static void ProcessRadioTxDone( void )
	{
		GetPhyParams_t getPhy;
		PhyParam_t phyParam;
		SetBandTxDoneParams_t txDone;

		if( MacCtx.pNvmCtx->DeviceClass != CLASS_C )
		{
			Radio.Sleep( );
		}
		// Setup timers
		TimerSetValue( &MacCtx.RxWindowTimer2, MacCtx.RxWindow2Delay );
		TimerStart( &MacCtx.RxWindowTimer2 );
		TimerSetValue( &MacCtx.RxWindowTimer1, MacCtx.RxWindow1Delay );
		TimerStart( &MacCtx.RxWindowTimer1 );
		
De timers die worden gestart hebben echter een extra offset van de Tx airtime die wordt toegevoegd aan de RTC timeout 
Aannemelijk is dat in de functie TimerStart()
        elapsedTime = RtcGetTimerElapsedTime( );
        obj->Timestamp += elapsedTime;
 

[00:08:29.277,493] <info> app: ###### ===== SendFrame ==== ######
[00:08:29.277,508] <info> app: STATUS      : OK
[00:08:30.434,702] <info> app: RTC start Alarm: 222497 Ticks / 6790 ms
[00:08:30.434,764] <info> app: On Time: seconds: 509, milliseconds: 729
[00:08:30.441,748] <info> app: Tx Done
[00:08:30.441,851] <info> app: RTC start Alarm: 103203 Ticks / 3149 ms
[00:08:30.441,913] <info> app: RTC start Alarm: 71911 Ticks / 2194 ms
[00:08:30.441,951] <info> app: RX1: 33816 Ticks/1032 ms, RX2: 65110 Ticks/1987 ms

3149-1987 = 1162
2194-1032 = 1162

[00:08:32.640,751] <info> app: Rx1 Ch: 2, Freq: 0, Datarate: 0, Timeout: 6
[00:08:32.641,751] <info> app: RX2 window discarded, because still processing RX1
[00:08:32.641,779] <info> app: RTC start Alarm: 98335 Ticks / 3000 ms
[00:08:32.839,079] <info> app: RTC start Alarm: 16770732 Ticks / 511802 ms
	
2019-05-27
	|	Code gecommit.
	|	SDKconfig tab realigned
	|	NVM opslag in NvmCtxMgmt.c en NvmCtxMgmt.h Deze implementatie is wel EEPROM georienteerd.
		- Lower level nvmm.c en eeprom-board.c
		Hoe groot moet de EEPROM zijn?
		-	Join DevNonce moet dus non-volatile worden opgeslagen plus extra variabelen
		-	RTC NVM store moet naar Flash worden omgezet.
	
	
2019-05-24
	|	TimeOff van de Bands lijkt niet af te lopen.
	|	Mac state continue 1 probleem
	|	NvmCtxMgmtStore() gecommentariseerd en nu wordt de LoRaWAN stack niet meer gestopt, maar blijft deze hangen op de dutycycle
		Onderzoek naar de volgende functie: joinDutyCycle = RegionCommonGetJoinDc( calcBackOffParams->ElapsedTime );
			void RegionCalcBackOff( LoRaMacRegion_t region, CalcBackOffParams_t* calcBackOff )
			RegionCalcBackOff( MacCtx.pNvmCtx->Region, &calcBackOff );
			calcBackOff.ElapsedTime			= SysTimeSub( SysTimeGetMcuTime( ), MacCtx.pNvmCtx->InitializationTime );
			SysTime_t SysTimeGetMcuTime( void )
				{
					SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };

					calendarTime.Seconds = RtcGetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );

					return calendarTime;
				}
	|	Oorzaak gevonden voor het probleem dat de offtime langer werdt en nooit nul wordt: De duty cycle waarde gaat van 100 (Offtime 146.817ms = 2:26)naar 1000 (Offtime= 1.481.517 ms 24:41). Aangezien de Offtime continue opnieuwe wordt berekend heeft dit als gevolg dat 

2019-05-23 Donderdag:
	|	Segger studio alignment gecorigeerd, zodat NotePad++ dezelfde text allignment geeft als in Segger Studio.
	|	Ook zonder timestamps in de logging kan de LoRaWAN implementatie blijven joinen met het back-end

2019-05-22 Woensdag:
	|	Een nieuwe bericht wordt al gestuurd terwijl de LoRaWAN statemachine nog bezig is en die daarna in een state blijft hangen, waar die nooit meer uit komt.
	|	TX timeout na het zenden van een Join bericht? Misschien is dit het probleem met dat de Stack continue busy is na een enkele join bericht?
		| TxTimeout is veel te snel na een transmit
		|	TxDone laten werken:
			LoRaMac.c: static void OnRadioTxDone( void );
		| Geen TX Done interrupt wanneer de TxTimeout wordt uitgeschakeld met een return in die functie
	|	RX2 window wordt niet op de juiste instellingen ingesteld
		TTN definitie uitgeschakeld, maar of dat de echte oplossing was, weet ik niet....
	|	RX2 wordt niet op DR0, maar op DR3 gezet. Waarschijnlijk als ik de TTN setting uitschakel dat het wel werkt.
		RX2 werkt nu wel. RX1 en RX2 worden op verschillende manieren van een frequentie voorzien. RX2 krijgt direct een frequentie mee, terwijl RX1 een kanaal krijgt die dan met de regionale parameters omgezet wordt naar een frequentie instelling voor de RFM.
	|	Timestamp Timer op 1MHz toegevoegd uit een vorig project van mijzelf. Hieruit blijkt dat de timing van de RX sloten bijna direct triggered.
	|	GPIO interrupt wordt wel aangeroepen, maar de callbacks zijn nog nul en roepen dus geen functeis aan
		callbacks worden nu correct geinitialiseerd en roepen de dioXfuncties aan.
		|	RX timeout is veel te vroeg.
			Nu de GPIO callbacks werken treed dit probleem niet meer op.
	|	Random DevNonce worden niet meer gebruikt, maar een incrementele counter in LoRaWAN 1.1.
			Random DevNonce weggehaald en onder de USE_RANDOM_DEV_NONCE definitie geimplementeerd.
	|	Random devNonce (USE_RANDOM_DEV_NONCE = 1) en USE_LRWAN_1_1_X_CRYPTO = 0, nu reageerd de sensor direct op een join request.
	-	Join DevNonce moet dus non-volatile worden opgeslagen.

2019-05-21 Dinsdag:
		-	App Timers for TimerInit functions Er lijkt een soort van App Timer te zijn gecreerd in timer.c?
		- App timers lijken nog niet helemaal correct te functioneren qua timing
	|	Terug gerolled naar een eerdere commit, die gepatched en het probleem gevonden waarom de blinky in deze commit wel werkte en de latere commit op master niet: een ongetermineerde CRITICAL_SECTION_END().
		Als die wordt gecomentariseerd werkt de blinky niet meer.
		Het verwijderen van de CRITICAL section flags om de sleep functie loste dit op.
		Voor testen had ik de flash init en handle functie in the main while loop uitgeschakeld, maar ook met die ingeschakeld werkt de blinky zoals je verwacht.
	-	Eerste Join bericht wordt in de buffer geplaatst, maar waarschijlijk nog niet verstuurd.
		Ik zie ook nog geen devNonce waarde toegekend worden aan het join bericht wanneer de DEVEUI en JOINEUI worden gekopieerd.
		-	Handmatig wissen van de offtime naar nul en macstate naar IDLE in de bands geeft Duty-cycle restricted status terug en geen nieuw bericht.
	|	NRF RNG voor het crreren van de DEVNONCE voor het joinen.	
		


2019-05-20 Maandag:
	|	FLASH opslag ipv EEPROM
	|	Eerste Join request wordt verstuurd.
	-	DevNonce niet random?
	-	Na het zenden van het eerste bericht geen niewue berichten? Airtime bezet of loopt de tijd counter niet af?
	
	
	
2019-05-16/17 Donderdag & Vrijdag vrij.	

	
2019-05-15 Woensdag:
	|	LoRaMAC initializatie gaf een errror zonder dat te melden en crashte op een Null functie pointer:
			| crasht op SeNvmCtxChanged() functie aanroep, wat een functie pointer is, maar niet geinitializeerd is. 
	|	App Timer blinky gemaakt om de microcontroller te forceren om wakker te worden, wat handig is voor debugging.
	|	SPI write and readback now work properly. Tested with the Logic Analyser. 
			-	SPI peripheral van de nRF heeft volledige controle over de NSS pin en kan dus niet gebruikt worden zoals in de sx1262 code wordt gedaan. Waar er handmatig de NSS hoog of laag wordt gezet.

2019-05-14:
	-	Test programma implementeren
	-	Hardware opzetten
	-	Hardware configureren in code
		-	RTC Timer
			| App Timer
			| 32kHz Clock
	|	RFM GPIO "GpioMcuInit" functie aangemaakt in gpio-board.c
	|	SPI
	|	RNG
	|	RTT en UART logging, extra functie toegeveogd voor het printen van een string met een hex array. Een stuk netter dan wat in de LoRaWAN stack werdt gedaan.
	|	Critical region definities 


2019-05-13:
-	Project opzetten in SES
-	Code succesvol compileren	


















